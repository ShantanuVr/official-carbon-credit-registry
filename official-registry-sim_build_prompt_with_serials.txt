Build Prompt — official-registry-sim (Official Carbon Credit Registry Simulator) — WITH UNIQUE SERIALS

Role for recipient: You are a senior full-stack engineer and solution architect. Deliver a production-quality simulation of an official carbon credit registry (for demo/education). It must feel realistic: role-based workflows, approvals, audit logs, document evidence handling (via adapter), on-chain anchoring via a separate service (provided later), and per-credit unique serialisation managed as ranges. Prioritize clarity, testability, and seedability.

0) Scope & Goals

- Simulate a government-style registry that governs carbon credit Projects → Issuances → Transfers → Retirements.
- Provide REST APIs for all core operations. UI is a clean operator console plus submitter portals.
- Integrate indirectly with blockchain via registry-adapter-api (mockable) and with an evidence locker (mockable).
- Include an IoT evidence summary pane (read-only) and a reference field for daily hash/CID (anchored elsewhere).
- Enforce unique serial numbers for credits via contiguous serial ranges per batch; print serials on retirement certificates.
- Everything is demo-able locally via Docker Compose + seed scripts.

1) Tech & Setup

Language/Framework
- Backend: Node.js 20+, TypeScript, Fastify (or NestJS if team prefers), Zod for validation.
- DB: Postgres 16 (SQLite acceptable for quick demo mode). Prisma ORM.
- Auth: JWT (RS256), cookie or Authorization header. Password + TOTP optional for Admins.
- UI: Next.js 15 (App Router), TypeScript, Tailwind + shadcn/ui. React Query (TanStack).
- Docs: OpenAPI 3.1 via fastify-oas (or Nest Swagger).
- Messaging: In-process events; adapter calls over HTTP (mockable).
- Audit: Write-ahead audit table + JSON diff snapshots.

Local run
  docker compose up -d
  pnpm i
  pnpm db:migrate
  pnpm db:seed:all
  pnpm dev    # spins api + ui with env from .env.local

Health checks
  curl http://localhost:4000/health
  open http://localhost:3000

Repository layout
official-registry-sim/
  /api
    /src
      /modules
        /auth
        /users
        /projects
        /issuances
        /credits
        /transfers
        /retirements
        /evidence
        /audits
        /reports
        /admin
      /lib (jwt, rbac, errors, logger, http)
      /prisma
      /tests (api e2e + unit)
    openapi.yaml
  /ui
    /app
      /(public) explorer, projects/[id]
      /(issuer) dashboard, new-project, submissions/[id]
      /(verifier) queue, review/[id]
      /(admin) users, policies, approvals, settings
    /components
    /lib (api client, hooks, rbac)
  /infra
    docker-compose.yml (api, ui, postgres, mailhog)
    /migrations
  /seed
    seed-users.ts
    seed-projects.ts
    happy-path.ts
  /docs
    domain-model.md
    rbac-matrix.md
    runbook.md

2) Domain & Lifecycle

Core entities
- Organization (issuer/org), User, Project, EvidenceFile (stored off-chain; keep CID/hash), IssuanceRequest, CreditBatch (ERC-1155-ish classId, quantity, serial range), SerialRange (per-owner sub-ranges), Transfer, Retirement (with retired serial range), AuditEvent.

Project states
- DRAFT → SUBMITTED → UNDER_REVIEW → NEEDS_CHANGES ↺ → APPROVED → ACTIVE → SUSPENDED/ARCHIVED.

Issuance workflow
- Issuer submits IssuanceRequest(projectId, vintage, qty, factorsRef, evidenceRefs).
- Verifier reviews, may request changes, or approve.
- Admin finalizes & issues → creates CreditBatch with serialStart/serialEnd; initial SerialRange allocated to issuer. Adapter is called; adapterTxId/onchainHash stored.

Transfer/Retirement
- Transfer: server allocates from sender’s SerialRange(s), splitting ranges as needed; creates new ranges for recipient.
- Retirement: allocate a contiguous sub-range; persist serialStart/serialEnd on Retirement; generate certificate with serials.

3) Roles & Access (RBAC)

Roles
- Admin: policy, users, final approvals, overrides.
- Verifier: review queues, doc review, approve/deny, comment, evidence checks.
- Issuer (Project Developer): create projects, upload evidence, request issuances, manage holdings, retire.
- Viewer: public explorer (no auth) + authenticated read-only (organization-scoped if needed).

RBAC matrix (summary)
Feature | Admin | Verifier | Issuer | Viewer
Create Project | ✓ | – | ✓ | –
Submit/Update Evidence | ✓ | c | ✓ | –
Review / Approve Project | ✓ | ✓ | – | –
Request Issuance | ✓ | – | ✓ | –
Approve Issuance | ✓ | ✓ | – | –
Finalize Issuance (mint + serialise) | ✓ | – | – | –
Transfer Credits | ✓ | – | ✓ | –
Retire Credits | ✓ | – | ✓ | –
View Explorer/Reports | ✓ | ✓ | ✓ | ✓
Manage Users/Policies | ✓ | – | – | –
(c = comment only)

4) UI Apps & Pages

Public Explorer
- / : Registry stats (projects, total credits, total retired).
- /projects list; filters: status, region, methodology.
- /projects/[id] details: description, vintages, total issued/retired, evidence tab (hashes, CID links), IoT summary (read-only digest: kWh, tCO₂e, last hash).
- /retirements/[certificateId] public certificate view showing retired serials.

Issuer Portal
- /issuer/dashboard holdings (quantity + serial ranges), pending reviews, last comments.
- /issuer/new-project form wizard (project meta, baseline, monitoring plan).
- /issuer/projects/[id] status timeline, evidence upload (doc drop + hash), comments thread.
- /issuer/issuance/new?projectId= create issuance request (vintage, quantity, factor reference).
- /issuer/credits balances, transfers, retire credits (modal previews exact serials).

Verifier Console
- /verifier/queue filters: project/issuance review type, SLA aging, risk flags.
- /verifier/review/[id] evidence viewer (file list + hash), IoT digest pane, comments, approve/changes/deny.

Admin Console
- /admin/approvals final approval queue (project & issuance).
- /admin/users CRUD users, assign roles, reset TOTP.
- /admin/policies registry parameters (allowed methodologies, factor references, min evidence).
- /admin/settings adapter endpoints, webhooks, branding.
- /admin/audits searchable audit log.

Common UI elements
- Status chips (state machine aware), activity timeline, diff modal (before/after JSON), integrity badge (hash match), “View on adapter” external link.

5) API (selected endpoints & contracts)

Auth
- POST /auth/login → { accessToken, refreshToken }
- POST /auth/refresh
- POST /auth/logout

Projects
- POST /projects (Issuer/Admin) create.
- GET /projects?status=&q=&page=
- GET /projects/:id
- PATCH /projects/:id (Issuer until submitted; Admin can override).
- POST /projects/:id/submit → moves to SUBMITTED.
- POST /projects/:id/request-changes (Verifier/Admin) { message }
- POST /projects/:id/approve (Verifier/Admin)

Evidence
- POST /projects/:id/evidence → {fileName, size, sha256, cid?} (actual bytes go to evidence-locker; this call records metadata).
- GET /projects/:id/evidence list.

Issuances
- POST /issuances { projectId, vintageStart, vintageEnd, quantity, factorRef, evidenceIds[] }
- GET /issuances?status=
- GET /issuances/:id
- POST /issuances/:id/request-changes
- POST /issuances/:id/approve (Verifier/Admin)
- POST /issuances/:id/finalize (Admin) → triggers adapter call; response carries {adapterTxId, onchainHash}; creates CreditBatch with serial range; allocates initial SerialRange to issuer.

Credits (holdings, transfers, retirements with serials)
- GET /credits/holdings?orgId=me
  → [{ batchId, projectId, vintageStart, vintageEnd, quantity, ranges: [{startSerial,endSerial}] }]
- POST /credits/transfer { toOrgId, batchId, quantity }
  → { transferId, allocated: [{startSerial,endSerial}] }
- POST /credits/retire { batchId, quantity, purpose?, beneficiary? }
  → { retirementId, certificateId, serialStart, serialEnd }

Reports/Explorer
- GET /reports/registry-stats
- GET /retirements/:certificateId

Audits
- GET /audits?entityType=&entityId=&actor=

Error envelope
{ "error": { "code": "ISSUANCE_NOT_FOUND", "message": "…", "traceId": "…" } }

(Provide OpenAPI YAML with schemas for all DTOs. Enforce Zod validation on input; Prisma schema below.)

6) Data Model (Prisma sketch with serials)

model User {
  id           String   @id @default(cuid())
  email        String   @unique
  name         String
  role         Role
  orgId        String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

enum Role { ADMIN VERIFIER ISSUER VIEWER }

model Organization {
  id        String  @id @default(cuid())
  name      String
  type      String
  users     User[]
}

model Project {
  id           String   @id @default(cuid())
  orgId        String
  title        String
  description  String
  country      String
  region       String?
  methodology  String
  baselineRef  String?
  status       ProjectStatus
  iotDigestRef String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

enum ProjectStatus { DRAFT SUBMITTED UNDER_REVIEW NEEDS_CHANGES APPROVED ACTIVE SUSPENDED ARCHIVED }

model EvidenceFile {
  id          String   @id @default(cuid())
  projectId   String
  fileName    String
  sizeBytes   Int
  sha256      String
  cid         String?
  uploadedBy  String
  createdAt   DateTime @default(now())
}

model IssuanceRequest {
  id           String   @id @default(cuid())
  projectId    String
  vintageStart DateTime
  vintageEnd   DateTime
  quantity     Int
  factorRef    String
  status       IssuanceStatus
  evidenceIds  String[]
  approvals    Json?
  adapterTxId  String?
  onchainHash  String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

enum IssuanceStatus { DRAFT SUBMITTED UNDER_REVIEW NEEDS_CHANGES APPROVED FINALIZED REJECTED }

model CreditBatch {
  id           String   @id @default(cuid())
  projectId    String
  vintageStart DateTime
  vintageEnd   DateTime
  totalIssued  Int
  totalRetired Int      @default(0)
  classId      String?
  serialStart  Int      // 1-based, inclusive
  serialEnd    Int      // inclusive
  createdAt    DateTime @default(now())
}

model SerialRange {
  id          String   @id @default(cuid())
  batchId     String
  ownerOrgId  String
  startSerial Int      // inclusive
  endSerial   Int      // inclusive
  createdAt   DateTime @default(now())
  @@index([batchId, ownerOrgId])
}

model CreditHolding {
  id        String   @id @default(cuid())
  orgId     String
  batchId   String
  quantity  Int
  createdAt DateTime  @default(now())
}

model Transfer {
  id        String   @id @default(cuid())
  fromOrgId String
  toOrgId   String
  batchId   String
  quantity  Int
  createdAt DateTime @default(now())
}

model Retirement {
  id            String   @id @default(cuid())
  orgId         String
  batchId       String
  quantity      Int
  purpose       String?
  beneficiary   String?
  certificateId String   @unique
  serialStart   Int
  serialEnd     Int
  createdAt     DateTime @default(now())
}

model AuditEvent {
  id          String   @id @default(cuid())
  actorUserId String?
  actorRole   Role?
  entityType  String
  entityId    String
  action      String
  beforeJson  Json?
  afterJson   Json?
  ip          String?
  createdAt   DateTime @default(now())
}

7) Serialisation Rules

- Batch-level serial range: serialStart = 1, serialEnd = quantity (per new batch).
- Initial SerialRange allocated to issuer: [1..quantity].
- Transfers consume earliest SerialRange(s), splitting as needed; create new SerialRange(s) for recipient.
- Retirements allocate a contiguous sub-range; store serialStart/serialEnd on Retirement and print on certificate.
- Prevent overlaps and gaps via DB transaction + constraints (validate on server; unit tests must cover splits/merges).

8) Human-readable serial format (display only)

<SIM-REG>-<ProjectCode>-<VintageStart>-<VintageEnd>-<BatchId>-<SerialStart>-<SerialEnd>
Example: SIM-REG-SOLARCO-PRJ001-2024-2024-BA01-00000001-00001000

9) Certificates

- Server-side HTML → PDF for Retirement.certificateId.
- Include: project title, vintage range, quantity, org, timestamp, factorRef, onchainHash (if present), SERIALS (range), QR to public URL.

10) Non-Functional

- Pagination on all list endpoints; filtering & sorting.
- 95%+ unit coverage on critical modules (auth, projects, issuance state machine, serial allocator).
- API e2e tests for happy path: project submit → approve → issuance approve + finalize (serialise) → balance → retire (serials) → certificate.
- Seed data creates: 1 Admin, 2 Verifiers, 2 Issuers, 3 Projects (varied statuses), 1 Issuance ready to approve.

11) State Machine Rules (unchanged core)

Project
- DRAFT → SUBMITTED (Issuer/Admin)
- SUBMITTED → UNDER_REVIEW (system)
- UNDER_REVIEW → NEEDS_CHANGES (Verifier/Admin with message)
- UNDER_REVIEW → APPROVED (Verifier/Admin)
- APPROVED → ACTIVE (Admin)

Issuance
- DRAFT → SUBMITTED
- SUBMITTED → UNDER_REVIEW
- UNDER_REVIEW → NEEDS_CHANGES | APPROVED
- APPROVED → FINALIZED (Admin only; adapter call) — also create CreditBatch and initial SerialRange
- * → REJECTED (Admin)

12) Integration Contracts (to be mocked initially)

Registry Adapter API (outbound)
- POST {ADAPTER_URL}/anchor/issuance
  Body: { issuanceId, projectId, quantity, vintageStart, vintageEnd, evidenceHashes[], factorRef }
  Returns: { adapterTxId, onchainHash }

Evidence Locker (outbound)
- POST {LOCKER_URL}/upload/init → returns signed URL
- Client uploads bytes → locker computes sha256, returns { cid, sha256 }
- POST /evidence/attach in our API stores metadata.

IoT Oracle (read-only)
- GET {ORACLE_URL}/digest/latest?projectId= → { kwh, tco2e, date, digestHash, cid }
  We only display these fields in UI and store iotDigestRef on project.

13) UX & Validation Notes

- Wizard forms with progressive validation; show requirements checklist (methodology, evidence min count, factor ref).
- Review pages show: evidence list with hash, factorRef, IoT digest quick stats, risk flags (e.g., missing baseline doc).
- Diff modals for every re-submission.
- Comment threads per project/issuance (stored as part of approvals JSON).
- Holdings page shows serial ranges; retirement modal previews allocated serials.

14) Observability

- Structured logs (pino) with traceId.
- Health endpoints: /health (db, downstream adapters ping), /ready.
- Basic metrics: requests, latencies, queue sizes; expose /metrics (Prometheus).

15) Seeds & Demo Runbook

Seeds
- Admin: admin@registry.test / Admin@123
- Verifiers: verifier1@…, verifier2@…
- Issuers: solarco@…, greengen@…
- Projects: Solar Farm A (DRAFT), Solar Farm B (UNDER_REVIEW), Solar Farm C (APPROVED)
- Evidence: PDFs with deterministic SHA256 (from /seed/evidence).
- Issuance: one SUBMITTED awaiting verifier approval.

Happy-path script (/seed/happy-path.ts)
1. Login as Issuer → create Project → upload Evidence → submit.
2. Login as Verifier → approve Project.
3. Issuer → create Issuance → submit.
4. Verifier → approve Issuance.
5. Admin → finalize Issuance (mock adapter returns {adapterTxId,onchainHash}); create CreditBatch and SerialRange.
6. Issuer → retire some credits → returns serialStart/serialEnd → certificate generated.
7. Viewer → open public certificate URL (shows serials).

16) Testing Strategy

- Unit: RBAC guard, state transitions, validators, serial allocator (split/merge, boundary cases).
- API e2e: vitest + supertest against ephemeral DB; snapshot OpenAPI.
- UI: Playwright smoke: submit project, reviewer approve, finalize issuance, retire with serial preview, view certificate.
- Contract tests: Mock adapter responses; assert we persist adapterTxId/onchainHash and batch serials.

17) Environment & Feature Flags

- .env: DATABASE_URL, JWT_ISSUER, JWT_PUBLIC_KEY, JWT_PRIVATE_KEY, ADAPTER_URL, LOCKER_URL, ORACLE_URL, REGISTRY_BRAND_NAME
- Flags: ENABLE_TOTP, READONLY_MODE, ALLOW_DEMO_UPLOAD_BYPASS

Acceptance Criteria (Definition of Done)
- All endpoints documented in OpenAPI and pass lint (spectral).
- End-to-end happy path works from a clean docker compose up.
- Audit log entries exist for every state transition and include actorRole and diffs.
- Public explorer and certificates are accessible without auth.
- Seed scripts provide a 5-minute demo from Project submission → Retirement certificate (with serials).
- 90%+ coverage on domain + serial allocator logic; CI pipeline runs unit + e2e.

Handoff notes
- Keep the adapter and oracle optional at boot with mock providers for offline demos.
- Ensure factorRef, onchainHash, and serial ranges are always shown where they matter (issuance review, holdings, certificate).
- Provide a small reports endpoint for registry totals to power the explorer hero cards.
