Build Prompt — official-registry-sim (Official Carbon Credit Registry Simulator)

Role for recipient: You are a senior full-stack engineer and solution architect. Deliver a production-quality simulation of an official carbon credit registry (for demo/education). It must feel realistic: role-based workflows, approvals, audit logs, document evidence handling (via adapter), and on-chain anchoring via a separate service (provided later). Prioritize clarity, testability, and seedability.

0) Scope & Goals

- Simulate a government-style registry that governs carbon credit Projects → Issuances → Transfers → Retirements.
- Provide REST APIs for all core operations. UI is a clean operator console plus submitter portals.
- Integrate indirectly with blockchain via registry-adapter-api (mockable) and with an evidence locker (mockable).
- Include an IoT evidence summary pane (read-only) and a reference field for daily hash/CID (anchored elsewhere).
- Everything is demo-able locally via Docker Compose + seed scripts.

1) Tech & Setup

Language/Framework
- Backend: Node.js 20+, TypeScript, Fastify (or NestJS if team prefers), Zod for validation.
- DB: Postgres 16 (SQLite acceptable for quick demo mode). Prisma ORM.
- Auth: JWT (RS256), cookie or Authorization header. Password + TOTP optional for Admins.
- UI: Next.js 15 (App Router), TypeScript, Tailwind + shadcn/ui. React Query (TanStack).
- Docs: OpenAPI 3.1 via fastify-oas (or Nest Swagger).
- Messaging: In-process events; adapter calls over HTTP (mockable).
- Audit: Write-ahead audit table + JSON diff snapshots.

Local run
  docker compose up -d
  pnpm i
  pnpm db:migrate
  pnpm db:seed:all
  pnpm dev    # spins api + ui with env from .env.local

Health checks
  curl http://localhost:4000/health
  open http://localhost:3000

Repository layout
official-registry-sim/
  /api
    /src
      /modules
        /auth
        /users
        /projects
        /issuances
        /credits
        /transfers
        /retirements
        /evidence
        /audits
        /reports
        /admin
      /lib (jwt, rbac, errors, logger, http)
      /prisma
      /tests (api e2e + unit)
    openapi.yaml
  /ui
    /app
      /(public) explorer, projects/[id]
      /(issuer) dashboard, new-project, submissions/[id]
      /(verifier) queue, review/[id]
      /(admin) users, policies, approvals, settings
    /components
    /lib (api client, hooks, rbac)
  /infra
    docker-compose.yml (api, ui, postgres, mailhog)
    /migrations
  /seed
    seed-users.ts
    seed-projects.ts
    happy-path.ts
  /docs
    domain-model.md
    rbac-matrix.md
    runbook.md

2) Domain & Lifecycle

Core entities
- Organization (issuer/org), User, Project, EvidenceFile (stored off-chain; keep CID/hash), IssuanceRequest, CreditBatch (ERC-1155-ish classId, quantity), Transfer, Retirement, AuditEvent.

Project states
- DRAFT → SUBMITTED → UNDER_REVIEW → NEEDS_CHANGES ↺ → APPROVED → ACTIVE → SUSPENDED/ARCHIVED.

Issuance workflow
- Issuer submits IssuanceRequest(projectId, vintage, qty, factorsRef, evidenceRefs).
- Verifier reviews, may request changes, or approve.
- Admin finalizes & issues → creates CreditBatch (on-chain anchoring via adapter, but registry keeps canonical numbers; adapter txId stored).

Transfer/Retirement
- Transfer: owner → recipient (off-chain registry record; optional on-chain hash reference in adapter).
- Retirement: burn from owner’s balance; generate RetirementCertificate (PDF/HTML) with references (project, vintage, qty, hash/CID, timestamp, signer).

3) Roles & Access (RBAC)

Roles
- Admin: policy, users, final approvals, overrides.
- Verifier: review queues, doc review, approve/deny, comment, evidence checks.
- Issuer (Project Developer): create projects, upload evidence, request issuances, manage holdings, retire.
- Viewer: public explorer (no auth) + authenticated read-only (organization-scoped if needed).

RBAC matrix (summary)
Feature | Admin | Verifier | Issuer | Viewer
Create Project | ✓ | – | ✓ | –
Submit/Update Evidence | ✓ | c | ✓ | –
Review / Approve Project | ✓ | ✓ | – | –
Request Issuance | ✓ | – | ✓ | –
Approve Issuance | ✓ | ✓ | – | –
Transfer Credits | ✓ | – | ✓ | –
Retire Credits | ✓ | – | ✓ | –
View Explorer/Reports | ✓ | ✓ | ✓ | ✓
Manage Users/Policies | ✓ | – | – | –
(c = comment only)

4) UI Apps & Pages

Public Explorer
- / : Registry stats (projects, total credits, total retired).
- /projects list; filters: status, region, methodology.
- /projects/[id] details: description, vintages, total issued/retired, evidence tab (hashes, CID links), IoT summary (read-only digest: kWh, tCO₂e, last hash).
- /retirements/[certificateId] public certificate view.

Issuer Portal
- /issuer/dashboard holdings, pending reviews, last comments.
- /issuer/new-project form wizard (project meta, baseline, monitoring plan).
- /issuer/projects/[id] status timeline, evidence upload (doc drop + hash), comments thread.
- /issuer/issuance/new?projectId= create issuance request (vintage, quantity, factor reference).
- /issuer/credits balances, transfers, retire credits (generate certificate).

Verifier Console
- /verifier/queue filters: project/issuance review type, SLA aging, risk flags.
- /verifier/review/[id] evidence viewer (file list + hash), IoT digest pane, comments, approve/changes/deny.

Admin Console
- /admin/approvals final approval queue (project & issuance).
- /admin/users CRUD users, assign roles, reset TOTP.
- /admin/policies registry parameters (allowed methodologies, factor references, min evidence).
- /admin/settings adapter endpoints, webhooks, branding.
- /admin/audits searchable audit log.

Common UI elements
- Status chips (state machine aware), activity timeline, diff modal (before/after JSON), integrity badge (hash match), “View on adapter” external link.

5) API (selected endpoints & contracts)

Auth
- POST /auth/login → { accessToken, refreshToken }
- POST /auth/refresh
- POST /auth/logout

Projects
- POST /projects (Issuer/Admin) create.
- GET /projects?status=&q=&page=
- GET /projects/:id
- PATCH /projects/:id (Issuer until submitted; Admin can override).
- POST /projects/:id/submit → moves to SUBMITTED.
- POST /projects/:id/request-changes (Verifier/Admin) { message }
- POST /projects/:id/approve (Verifier/Admin)

Evidence
- POST /projects/:id/evidence → {fileName, size, sha256, cid?} (actual bytes go to evidence-locker; this call records metadata).
- GET /projects/:id/evidence list.

Issuances
- POST /issuances { projectId, vintageStart, vintageEnd, quantity, factorRef, evidenceIds[] }
- GET /issuances?status=
- GET /issuances/:id
- POST /issuances/:id/request-changes
- POST /issuances/:id/approve (Verifier/Admin)
- POST /issuances/:id/finalize (Admin) → triggers adapter call; response carries {adapterTxId, onchainHash} to be stored.

Credits
- GET /credits/balance?ownerId=me
- POST /credits/transfer { from=me, toOrgId, batchId, quantity }
- POST /credits/retire { batchId, quantity, purpose, beneficiary } → creates certificate.

Reports/Explorer
- GET /reports/registry-stats
- GET /retirements/:certificateId

Audits
- GET /audits?entityType=&entityId=&actor=

Error envelope
{ "error": { "code": "ISSUANCE_NOT_FOUND", "message": "…", "traceId": "…" } }

(Provide OpenAPI YAML with schemas for all DTOs. Enforce Zod validation on input; Prisma schema below.)

6) Data Model (Prisma sketch)

User(id, email, name, role, orgId, createdAt, updatedAt)
Role = ADMIN | VERIFIER | ISSUER | VIEWER
Organization(id, name, type)
Project(id, orgId, title, description, country, region, methodology, baselineRef, status, iotDigestRef, createdAt, updatedAt)
ProjectStatus = DRAFT | SUBMITTED | UNDER_REVIEW | NEEDS_CHANGES | APPROVED | ACTIVE | SUSPENDED | ARCHIVED
EvidenceFile(id, projectId, fileName, sizeBytes, sha256, cid, uploadedBy, createdAt)
IssuanceRequest(id, projectId, vintageStart, vintageEnd, quantity, factorRef, status, evidenceIds[], approvals(json), adapterTxId, onchainHash, createdAt, updatedAt)
IssuanceStatus = DRAFT | SUBMITTED | UNDER_REVIEW | NEEDS_CHANGES | APPROVED | FINALIZED | REJECTED
CreditBatch(id, projectId, vintageStart, vintageEnd, totalIssued, totalRetired, classId, createdAt)
CreditHolding(id, orgId, batchId, quantity, createdAt)
Transfer(id, fromOrgId, toOrgId, batchId, quantity, createdAt)
Retirement(id, orgId, batchId, quantity, purpose, beneficiary, certificateId, createdAt)
AuditEvent(id, actorUserId, actorRole, entityType, entityId, action, beforeJson, afterJson, ip, createdAt)

7) Security, Integrity, Audit

- All mutating endpoints require JWT with role claims; organization scoping for Issuer.
- Evidence integrity: require sha256 at upload, store immutable metadata; UI shows “hash verified” badge.
- On finalization, store adapterTxId and onchainHash (string) returned by adapter; show on UI as verifiable reference.
- Audit every state change. Include IP and actor.

8) Factor & Conversion References

- Don’t compute factors here; only reference an external factor ID/version in factorRef.
- Display it prominently on issuance review and certificate.

9) Certificates

- Generate server-side HTML → PDF for Retirement.certificateId.
- Include: project title, vintage range, quantity, org, timestamp, factorRef, onchainHash (if present), QR to public URL.

10) Non-Functional

- Pagination on all list endpoints; filtering & sorting.
- 95%+ unit coverage on critical modules (auth, projects, issuance state machine).
- API e2e tests for happy path: project submit → approve → issuance approve → finalize → balance → retire → certificate.
- Seed data creates: 1 Admin, 2 Verifiers, 2 Issuers, 3 Projects (varied statuses), 1 Issuance ready to approve.

11) State Machine Rules (enforced server-side)

Project
- DRAFT → SUBMITTED (Issuer/Admin)
- SUBMITTED → UNDER_REVIEW (system)
- UNDER_REVIEW → NEEDS_CHANGES (Verifier/Admin with message)
- UNDER_REVIEW → APPROVED (Verifier/Admin)
- APPROVED → ACTIVE (Admin)

Issuance
- DRAFT → SUBMITTED
- SUBMITTED → UNDER_REVIEW
- UNDER_REVIEW → NEEDS_CHANGES | APPROVED
- APPROVED → FINALIZED (Admin only; adapter call)
- * → REJECTED (Admin)

12) Integration Contracts (to be mocked initially)

Registry Adapter API (outbound)
- POST {ADAPTER_URL}/anchor/issuance
  Body: { issuanceId, projectId, quantity, vintageStart, vintageEnd, evidenceHashes[], factorRef }
  Returns: { adapterTxId, onchainHash }

Evidence Locker (outbound)
- POST {LOCKER_URL}/upload/init → returns signed URL
- Client uploads bytes → locker computes sha256, returns { cid, sha256 }
- POST /evidence/attach in our API stores metadata.

IoT Oracle (read-only)
- GET {ORACLE_URL}/digest/latest?projectId= → { kwh, tco2e, date, digestHash, cid }
  We only display these fields in UI and store iotDigestRef on project.

13) UX & Validation Notes (concise)

- Wizard forms with progressive validation; show requirements checklist (methodology, evidence min count, factor ref).
- Review pages show: evidence list with hash, factorRef, IoT digest quick stats, risk flags (e.g., missing baseline doc).
- Diff modals for every re-submission.
- Comment threads per project/issuance (stored as part of approvals JSON).

14) Observability

- Structured logs (pino) with traceId.
- Health endpoints: /health (db, downstream adapters ping), /ready.
- Basic metrics: requests, latencies, queue sizes; expose /metrics (Prometheus).

15) Seeds & Demo Runbook

Seeds
- Admin: admin@registry.test / Admin@123
- Verifiers: verifier1@…, verifier2@…
- Issuers: solarco@…, greengen@…
- Projects: Solar Farm A (DRAFT), Solar Farm B (UNDER_REVIEW), Solar Farm C (APPROVED)
- Evidence: PDFs with deterministic SHA256 (from /seed/evidence).
- Issuance: one SUBMITTED awaiting verifier approval.

Happy-path script (/seed/happy-path.ts)
1. Login as Issuer → create Project → upload Evidence → submit.
2. Login as Verifier → approve Project.
3. Issuer → create Issuance → submit.
4. Verifier → approve Issuance.
5. Admin → finalize Issuance (mock adapter returns {adapterTxId,onchainHash}).
6. Issuer → retire some credits → certificate generated.
7. Viewer → open public certificate URL.

16) Testing Strategy

- Unit: RBAC guard, state transitions, validators.
- API e2e: Using vitest + supertest against ephemeral DB; snapshot OpenAPI.
- UI: Playwright smoke: submit project, reviewer approve, finalize issuance, view certificate.
- Contract tests: Mock adapter responses; assert we persist adapterTxId/onchainHash.

17) Environment & Feature Flags

- .env: DATABASE_URL, JWT_ISSUER, JWT_PUBLIC_KEY, JWT_PRIVATE_KEY, ADAPTER_URL, LOCKER_URL, ORACLE_URL, REGISTRY_BRAND_NAME
- Flags: ENABLE_TOTP, READONLY_MODE, ALLOW_DEMO_UPLOAD_BYPASS (skips locker round-trip in local dev).

Acceptance Criteria (Definition of Done)
- All endpoints documented in OpenAPI and pass lint (spectral).
- End-to-end happy path works from a clean docker compose up.
- Audit log entries exist for every state transition and include actorRole and diffs.
- Public explorer and certificates are accessible without auth.
- Seed scripts provide a 5-minute demo from Project submission → Retirement certificate.
- 90%+ coverage on domain logic; CI pipeline runs unit + e2e.

Handoff notes
- Keep the adapter and oracle optional at boot with mock providers for offline demos.
- Ensure factorRef and onchainHash are always shown where they matter (issuance review, certificate).
- Provide a small reports endpoint for registry totals to power the explorer hero cards.
